<!DOCTYPE html>

<html>

<head>
    <link rel="icon" 
      type="image/png" 
      href="favicon.ico">
    <title>B612</title>
</head>

<style>
    *{margin:0; padding:0; background-color: black; font-family:'Courier New', Courier, monospace}
    .hidden{
        display:none;
    }
    #display{        
        width: 100vmin;
        height:100vmin;
        display:block;
        margin:auto;
    }
    #overlay{
        width: 100vmin;
        height:100vmin;
        position:absolute;
        margin:auto;
        top:0px;
        left:0px;
        right:0px;
        zborder:1px solid #f0f;
        background:transparent;
    }
    .crisp{
        image-rendering:pixelated;    
    }
    .pac{
        background-color:#888;
        color:#fff;
        padding: 1em;
    }
</style>

<!-- http://davidbau.com/archives/2010/01/30/random_seeds_coded_hints_and_quintillions.html -->
<script src="./vendor/seedrandom.js"> </script>

<!-- https://github.com/mrdoob/stats.js 
<script src="./vendor/stats.js"></script>
-->

<!-- https://tonejs.github.io/ -->
<script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>

<!-- game code -->
<script src="perfmon.js"></script>

<script >var perfmon = new PerfMon();</script>

<script src="MathEx.js"></script>

<script src="AssetsFixer.js"> </script>
<script src="Assets.js"> </script>

<script src="Camera.js"></script>
<script src="RendererWebGL.js"> </script>
<script src="RxSprite.js"> </script>

<script src="GameObject.js"> </script>
<script src="GoStar.js"> </script>
<script src="GoPlanet.js"> </script>
<script src="GoActor.js"> </script>
<script src="GoLatern.js"> </script>
<script src="Game.js"></script>
<script src="Oracle.js"></script>
<script src="NavMap.js"></script>
<script src="GameObjectController.js"></script>

<script>

"use strict";

var renderContext = undefined;
const RM_HIRES = "hires";
const RM_RETRO = "retro";
var renderMode = RM_HIRES;

function setRenderMode(mode){    
    if (mode==renderMode){
        return;
    }
    console.log("setRenderMode",mode)
    renderMode = mode;
    if (mode==RM_HIRES){        
        setRes(1024,1024,false);        
    }
    if (mode==RM_RETRO){        
        setRes(128,128,true);
    }
}

var player = undefined;
var planets = [];
var stars = [];

var tsecond = 0
var time_for_physics = 0;
var time_for_frames = 0;
const time_step = 10;
let time_multiplier = 1.0;


var cam_back = new Camera(0);
var cam_front = new Camera(0);
var game = new Game();
Game.currentGame = game;
let cnt_frame = 0;

let rose = undefined, retro = undefined;
let prince, fox, sheep, box, scarf, bush, star, latern, frost;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



// make background
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function make_stars(){
    var bg = new GameObject();
    game.objects.background.push(bg);
    bg.renderer = new RenderSprite("bg");
    bg.position = {x:400,y:400};
    bg.scale = 2;
    bg.z_1 = 0.1;

    stars = [];

    Math.seedrandom("starfield");
    for(let i=0;i<50;i++){
        let go = new GoStar();
        game.objects.background.push(go);
        go.position = {x:MathEx.randRange(10,790), y:MathEx.randRange(10,790)};
        go.s = MathEx.randRange(0.03,0.075);
        go.k = MathEx.randomAngle();       
        go.z_1 = MathEx.randRange(0.2,0.7); 
        stars.push(go);
    }

    let piasecki = [[174,215],[326,259],[370,325],[430,379],[600,450],[535,524],[406,468]];
    for(let i in piasecki){
        let [x,y] = piasecki[i];
        let go = new GoStar();
        game.objects.background.push(go);
        go.position = {x:x,y:y+20};
        go.s = 0.2;
        go.k = MathEx.randomAngle(); //-i*0.05;
        go.z_1 = 0.2; 
    }

}    

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class EfRGB extends Effect{
    static Red = new EfRGB([1,0,0]);
    static Blu = new EfRGB([0,0,1]);
    static Mag = new EfRGB([1,0,1]);
    constructor(rgb){
        super();
        this.cmul = rgb.concat([1,]);
        this.cadd = rgb.concat([0,]);
    }
    Apply(go){
        go.renderer.cmul = this.cmul;
        go.renderer.cadd = this.cadd;
    }
}


var atlas_name = "star";

// Game.render
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function render(){
    var t1 = perfmon.time;
    stats.beginSeg("rx");

    if (latern!==undefined) {
        let t = latern.globalPosition;
        for(let p of planets){
            const pos = p.globalPosition;
            p.lightRotation = Math.PI*0.7+Math.atan2(t.y-pos.y,t.x-pos.x);
        }
    }else{        
        for(let p of planets){
            const pos = p.globalPosition;
            const t = mouse;
            p.lightRotation = Math.PI*0.7+Math.atan2(t.y-pos.y,t.x-pos.x);
        }
    }


    if (renderContext.BeginScene()){
        cnt_frame+=1;

        if (!document.getElementById("overlay").classList.contains("hidden"))
        if ((cnt_frame%4==0)){
            gx_overlay.clearRect(0, 0, 800, 800);            

            var astar = staratlas[atlas_name];
            
            for(let p of game.objects.solid){
                gx_circle(gx_overlay,
                    p.globalPosition.x, p.globalPosition.y, p.radius, 'rgba(255,128,255,0.7)',
                    p.globalRotation, p.globalRotation + PI2-0.1
                );

            }

            let planetindex = function(p){
                for(let i in planets){
                    if (planets[i]===p) return i;
                }
                return -1;
            }

            for(let p of planets)
            {
                //let p = planets[0];
                let seg = [];
                let gx = gx_overlay;
                for(let hit of astar.maps[p]){
                    let dst = hit.dst;
                    let k = hit.k;
                    seg.push(hit);
                    if (seg.length>1){                        
                        gx.beginPath();
                        var [h1,h2] = seg;
                        let k1 = h1.k;
                        let k2 = h2.k;


                        let style = 'rgba(128,128,255,0.3)'
                        let r2 = 40+planetindex(h1.dst)*5;
                        if (h1.dst===undefined){
                            style = 'rgba(255,128,128,0.3)'
                            r2 = 120;
                        }
                        if (h1.dst===p){
                            style = 'rgba(255,255,128,0.3)'
                            r2 = 30;
                        }

                        let k2a = Math.max(k1,k2- 4.0/(p.radius+10));
                        let k2b = Math.max(k1,k2- 4.0/(p.radius+r2));

                        gx.arc(p.globalPosition.x,p.globalPosition.y,p.radius+10,k1,k2a,false);
                        gx.arc(p.globalPosition.x,p.globalPosition.y,p.radius+r2,k2b,k1,true);
                        gx.closePath();                        
                        gx.strokeStyle = style;
                        gx.stroke();
                        gx.fillStyle = style;
                        gx.fill();
                        seg.shift();
                        
                    }                    
                }
            }

            {
                let atlas_name_map = {"fox":fox, "star": star, "prince": prince, "sheep": sheep}
                let actor = atlas_name_map[atlas_name];

                let angle = actor.rotation-PI05; //Math.atan2(v.y,v.x)+Math.PI;
                let prediction = astar.getDestination(getTruePlanet(actor),angle);

                if (prediction!==undefined){
                    let p = prediction.dst;
                    if (p!==undefined){
                        gx_disk(gx_overlay,
                                p.globalPosition.x, p.globalPosition.y, p.radius, 'rgba(255,255,0,0.2)',
                                p.globalRotation, p.globalRotation + PI2-0.1
                            );
                    }
                }
            }
        }

        //camera.opacity = 1.;
        let cam_target = getPlanet(player);
        if (player.behaviour instanceof BeaJump){
            cam_target = player;
        }
        cam_back.setTarget(player);
                
        renderContext.camera = cam_back;
        GameObject.RenderAll(game.objects.background);
                
        renderContext.camera = cam_front;
        GameObject.RenderAll(game.objects.solid);        

        renderContext.EndScene();
    }
    
    perfmon.watch("rx",t1);
    stats.endSeg("rx");
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function getPlanet(go){
    if (go===undefined){
        return undefined;
    }
    let be = go.behaviour;
    if (be!==undefined){
        return be.planetLocation;
    }else{
        return undefined;
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function getTruePlanet(go,depth=3){
    if (go===undefined || !depth){
        return undefined;
    }
    if (go instanceof GoPlanet){
        return go;
    }
    if (go instanceof GoActor){
        let be = go.behaviour;
        if (be===undefined){
            return undefined;
        }else{
            return getTruePlanet(be.planetLocation,depth-1);
        }
    }
}

// Game.physics
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function physics(dt){
    time_for_physics=Math.max(Math.min(300,time_for_physics+dt),0);
    while(time_for_physics>time_step){
        let t1 = perfmon.time;
        stats.beginSeg("ph");
        time_for_physics-=time_step;
        
        GameObject.UpdateAll(game.objects.solid);
        GameObject.UpdateAll(game.objects.background);
        for(let go of game.objects.solid){
            go.DispatchAll();
        }

        if (rose!==undefined){            
            if (rose===getPlanet(player)){
                rose.jump();
                player.spawnAtPlanet(getPlanet(rose),rose.globalRotation);
            }
            if (getPlanet(rose)===getPlanet(player)){
                let ix = Math.floor(MathEx.randRange(0,planets.length-1));
                let new_planet = planets[ix]
                rose.jump();
                rose.spawnAtPlanet(new_planet,MathEx.randomAngle());
            }else{
            }
        }

        {
            let cam_target = player;
            if (player.behaviour instanceof BeaStand){
                cam_target = player.behaviour.planet;
            }    
            if (player.behaviour instanceof BeaJump){
                cam_target = player.behaviour.p2 || player.behaviour.p1;
            }    
            //camera.setTarget(cam_target);
            cam_front.Update();
            cam_back.Update();
        }

        stats.endSeg("ph");
        perfmon.watch("ph",t1);
    }
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

let ts1, ts2;

const MS_PER_FRAME = 1000/50;
let cnt_frames = 0;

function szround(v,m){
    return Math.round(m*v)/m;
}

//var stats = new Stats();
var stats = {
     beginSeg: function(){},
     endSeg: function(){},
     dom: undefined,
     begin: function(){},
     end: function(){},
     showPanel: function(){},
     reset: function(){},
};

function animationFrame(timestamp){
    
    stats.begin();

    try{
        timestamp = perfmon.time;
        if (ts1===undefined){
            ts1 = timestamp;
            ts2 = timestamp;
        }   
        { 
            const dt = ts2-ts1;
            //let cfdt = Math.sin(perfmon.time*0.001);
            ///cfdt*=cfdt;
            physics(dt*time_multiplier);
            time_for_frames=Math.min(120,time_for_frames+dt);
            while(time_for_frames>MS_PER_FRAME){
                render();
                cnt_frames+=1;
                time_for_frames-=MS_PER_FRAME;
            }
        }

        {
            let dt = perfmon.time - tsecond 
            if (dt>1000){
                const metrics = perfmon.metrics;
                // structure of one second of the game:
                const time_in_frame = PerfMon.sum(metrics.ph) + PerfMon.sum(metrics.rx);
                const time_in_glx = PerfMon.sum(metrics.gl);
                const time_in_rdx = PerfMon.sum(metrics.rx);
                const time_in_phy = PerfMon.sum(metrics.ph);
                const pload = time_in_frame*100/dt;
                const pphy = time_in_phy*100/time_in_frame;
                const prdx = time_in_rdx*100/time_in_frame;
                const pglx = time_in_glx*100/time_in_rdx;
                if (pload>0){
                    document.getElementById("fps").innerHTML = `CPU:${szround(pload,100)}% R:${metrics.rx.length}#${szround(prdx,100)}% (${szround(pglx,100)}%) P:${szround(pphy,100)}%`
                }else{
                    document.getElementById("fps").innerHTML = '';
                }

                perfmon.reset();
                tsecond = perfmon.time;
                stats.reset();
            }
        }

        perfmon.metrics.ts.push(ts2-ts1);
        ts1 = ts2;
        ts2 = timestamp;    
        window.requestAnimationFrame(animationFrame);
    }catch(e){
        console.log("EXCEPTION:",e)
        document.getElementById("fps").innerHTML = e;
        throw e;
    }

    stats.end();
}


function shuffle(array) {
  let currentIndex = array.length,  randomIndex;

  // While there remain elements to shuffle...
  while (currentIndex != 0) {

    // Pick a remaining element...
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex--;

    // And swap it with the current element.
    [array[currentIndex], array[randomIndex]] = [
      array[randomIndex], array[currentIndex]];
  }

  return array;
}



var staratlas = {};

function make_demo(){
    planets = []
    for(let y=0;y<3;y++){
        var nx = 3;
        if (y==1) {nx = 4;}
        for(let x=0;x<nx;x++)    
        {
            let p = new GoPlanet(`level1-${x}-${y}`,(x+1-(y%2)*0.5)*200,(y-1+0.5)*230+400-230*0.5);
            p.position.x+=Math.random()*20-10;
            p.position.y+=Math.random()*20-10;
            planets.push(p)
            game.objects.solid.push(p);
        }
    }    
        
    let actors = ['star','prince','fox','sheep'];
    for(let actorname of actors){
        var astar = new NavMap();
        console.log("NavMap",actorname);
        astar.process(planets, new GoActor(actorname)); // radius required
        staratlas[actorname] = astar;
    }

    
    prince = new GoActor("prince");    
    game.objects.solid.push(prince);
    prince.spawnAtPlanet(planets[0],MathEx.randomAngle());    

    fox = new GoActor("fox");
    game.objects.solid.push(fox);
    fox.spawnAtPlanet(planets[1],MathEx.randomAngle())
    /*
    fox.addHandler(GameEvent.TOUCHDOWN,function(){
        if (getPlanet(fox)!==getPlanet(star)){
            paths = astar.getPaths(getPlanet(fox),getPlanet(star));
            if (paths.length==0){
                let delay = Math.round(MathEx.randRange(600,1600));
                setTimeout(function(){ fox.jump(); } ,delay);    
            }                
        }
    });*/    
    

    sheep = new GoActor("sheep");
    game.objects.solid.push(sheep);
    sheep.spawnAtPlanet(planets[2],MathEx.randomAngle());

    rose = new GoActor("rose");
    game.objects.solid.push(rose);
    rose.effect = new EfBlink();
    rose.spawnAtPlanet(planets[3],MathEx.randomAngle());

    box = new GoActor("box");
    game.objects.solid.push(box);
    box.spawnAtPlanet(planets[1],MathEx.randomAngle());
    box.radius*=0.7;

    function frost_slow(){
        time_multiplier = Math.max(0.2,time_multiplier - 0.3);
        console.log("time_multiplier",time_multiplier);
    }
    function frost_speed(){
        time_multiplier = Math.min(1,time_multiplier + 0.3);
        console.log("time_multiplier",time_multiplier);
    }

    for(let i=0;i<3;i++){
        frost = new GoActor("frost");
        game.objects.solid.push(frost);
        frost.spawnAtPlanet(planets[5],MathEx.randomAngle());    
        frost.queue = [];
        frost.addHandler(GameEvent.TOUCHDOWN,frost_slow);
        frost.addHandler(GameEvent.JUMP,frost_speed);
    }
    planets[5].queue = [];
    planets[5].addHandler(GameEvent.TOUCHDOWN,frost_slow);
    planets[5].addHandler(GameEvent.JUMP,frost_speed);    

    retro = new GoActor("retro");
    game.objects.solid.push(retro);
    retro.spawnAtPlanet(planets[planets.length-1],MathEx.randomAngle())

    scarf = new GoActor("scarf");
    game.objects.solid.push(scarf);
    scarf.spawnAtPlanet(planets[planets.length-2],MathEx.randomAngle());

    bush = new GoActor("bush");
    game.objects.solid.push(bush);
    bush.spawnAtPlanet(planets[planets.length-3],MathEx.randomAngle());
    
    
    star = new GoActor("star")    
    game.objects.solid.push(star);
    star.spawnAtPlanet(planets[planets.length-4],MathEx.randomAngle());    

    latern = new GoLatern();
    game.objects.solid.push(latern);
    latern.spawnAtPlanet(planets[4],MathEx.randomAngle());    

    let me = planets[4];
    me.addHandler(GameEvent.TOUCHDOWN,function(){
        latern.lit+=1;
        console.log("platern+",latern.lit);
    });
    me.addHandler(GameEvent.JUMP,function(){
        latern.lit-=1;
        console.log("platern-",latern.lit);
    });

    latern.addHandler(GameEvent.TOUCHDOWN, function(me){
        me.lit+=1;
        console.log("latern+",me.lit);
    });
    latern.addHandler(GameEvent.JUMP, function(me){
        me.lit-=1;
        console.log("latern-",me.lit);
    });



    player = star;
    player.addHandler(GameEvent.JUMP,function(){
        console.log("Player.JUMP");
        //navigator.vibrate(30);
        //synth.triggerAttack("C3");        
    });
    player.addHandler(GameEvent.TOUCHDOWN,function(that,args){
        console.log("Player.TDOWN",args);
        //navigator.vibrate(30);
        //synth.triggerRelease();
        
        let planet = getPlanet(that);
        if (planet===getPlanet(retro) || planet===retro){
            let mode = RM_HIRES;
            if (renderMode == mode) mode = RM_RETRO;
            setRenderMode(mode);
        }    
    });

    fox.controller = new GocFollow(star);
    sheep.controller = new GocFollow(star);
    prince.controller = new GocFollow(star);
    
    GameObject.UpdateAll(game.objects.solid);

    //ai_random(fox);
    //ai_random(prince);
    //ai_random(sheep);
   
}

function make_intro(){
    var p1 = new GoPlanet(`level1-0-0`,300,400);
    game.objects.solid.push(p1);
    var p2 = new GoPlanet(`level1-0-1`,500,400);
    game.objects.solid.push(p2);
    planets = [p1,p2];
    astar.process(planets, new GoActor("prince")); // radius required
    prince = new GoActor("prince");
    prince.spawnAtPlanet(p1,0);
    game.objects.solid.push(prince);
    player = prince;
}

const synth = new Tone.AMSynth({
			harmonicity: 2.5,
			oscillator: {
				type: "fatsawtooth"
			},
			envelope: {
				attack: 0.1,
				decay: 0.2,
				sustain: 0.2,
				release: 2 // 0.3
			},
			modulation: {
				type: "square"
			},
			modulationEnvelope: {
				attack: 0.5,
				decay: 0.01
			}
		}).toDestination();


const bgsynth = new Tone.AMSynth({
			harmonicity: 2.5,
			oscillator: {
				type: "fatsawtooth"
			},
			envelope: {
				attack: 0.1,
				decay: 0.2,
				sustain: 0.2,
				release: 2 // 0.3
			},
			modulation: {
				type: "square"
			},
			modulationEnvelope: {
				attack: 0.5,
				decay: 0.01
			}
		}).toDestination();

function main(){

    console.log("main().enter")
    renderContext = new RendererWebGL(800,800); // FIXME 800

    let tick = new Date().now;
    let pnames = ['planet','sprite','glow','fse_pass','fse_accu'];
    let fetchbatch = []
    for(let pn of pnames){
        let vsn = pn;
        let fsn = pn;
        fetchbatch.push(fetch(`assets/${vsn}.vsh.glsl?`+tick).then(x=>x.text()));
        fetchbatch.push(fetch(`assets/${fsn}.fsh.glsl?`+tick).then(x=>x.text()));
    }
    Promise.all(fetchbatch).then((res)=>{
        let programs = [];
        for(let i=0;i<pnames.length;i++){
            programs.push([pnames[i],res[i*2],res[i*2+1]]);
        }
        renderContext.prepstage(programs);
    });

    stats.showPanel( 1 ); // 0: fps, 1: ms, 2: mb, 3+: custom
    if (stats.dom!==undefined){
        document.body.appendChild( stats.dom );    
    }

    setRes(800,800,false); // FIXME

    //var go = new GameObject();
    //go.renderer = new RenderSprite("planet");
    //go.position = {x:128,y:128};

    make_stars();

    //make_intro();
    make_demo();

    animationFrame();


    gx_overlay = _createGraphics2d("overlay",800,800);
    
    console.log("main().exit");
}

let gx_overlay;

function ai_random(actor){
    let delay = Math.round(MathEx.randRange(600,1600));
    setTimeout(function() {
        ai_random(actor);
        actor.jump()
    }
    ,delay);    
}


function setFullScreen() {
  var doc = window.document;
  var docEl = doc.documentElement;
  docEl = document.getElementById("display");

  var requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;
  var cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;
  
  if(!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
    requestFullScreen.call(docEl);
  }

}

function toggleOverlay() {
    let overlay = document.getElementById("overlay");
    if (overlay.classList.contains("hidden")){
        overlay.classList.remove("hidden");
    }else{
        overlay.classList.add("hidden");
    }
}

function toggleFullScreen() {
  var doc = window.document;
  var docEl = doc.documentElement;
  docEl = document.getElementById("display");

  var requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;
  var cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;

  if(!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
    requestFullScreen.call(docEl);
  }
  else {
    cancelFullScreen.call(doc);
  }
}

document.onclick = function(){
    player.jump();
    //bgsynth.triggerAttack("C2");
    //bgsynth.triggerAttack("E2");
    //bgsynth.triggerAttack("G2");
}

//document.ondblclick = function(){
//    setFullScreen();
//}

var mouse = { x:0, y:0};

document.onmousemove = function(e){
    mouse = {x:e.offsetX, y:e.offsetY};
}

function setRes(sx,sy,crisp){
    let canvas = document.getElementById("display");    
    canvas.width = sx;
    canvas.height= sy;
    if (crisp){
        canvas.classList.add("crisp");
    }else{
        canvas.classList.remove("crisp");
    }
    renderContext.rt_screen.vp = {sx:sx,sy:sy};
}

</script>


<body onload="main()">
    <span id="fps" style="position:absolute;top:0;left:0;color:white">Loading...</span>
    <canvas id="display"></canvas>
    <canvas id="overlay" class="hidden"></canvas>
    <br>
    <button id="toggle_fullscreen" class="pac" onclick="toggleFullScreen()">Full Screen</button>
    <button id="toggle_fullscreen" class="pac" onclick="toggleOverlay()">Debug Overlay</button>
    <span><a href="https://github.com/kulasty/kulasty.github.io/tree/main/b612/2021">sourcecode</a></span>
    <!--
    <button onclick="setRes(800,800)" class="pac">800</button>
    <button onclick="setRes(200,200)" class="pac">200</button>
    <button onclick="setRes(96,96)" class="pac">96</button>
    -->

</body>


</html>
